# ADR-001: Hexagonal Architecture + Domain-Driven Design (Tactical)

**Date**: 2026-02-20  
**Status**: ACCEPTED  
**Author**: Architecture Team  
**Supersedes**: N/A  
**Superseded by**: N/A

## Context

The appointment management system has evolved from a simple CRUD application to a complex domain with multiple business rules and integration points:

- **Multiple validation rules**: Office hours (8:00-18:00), capacity constraints, consultation room availability, doctor schedule conflicts
- **Distributed operations**: REST API Producer service handles appointments, separate Consumer service processes notifications and availability updates
- **Asynchronous processing**: Need to decouple appointment creation from downstream notification/synchronization
- **Scalability requirements**: Foundation must support future evolution (microservices, CQRS, Event Sourcing)
- **Team skill development**: Codebase should educate developers on enterprise architectural patterns

### Business Complexity

The appointment domain involves:

- **Entities**: Appointment, Doctor, Patient, ConsultingRoom, Availability
- **Value Objects**: AppointmentId, ConsultationTime, DateTime
- **Policies**: OfficeHourPolicy, CapacityPolicy, DoctorSchedulePolicy
- **Domain Events**: AppointmentCreatedEvent, AppointmentCancelledEvent, AppointmentRescheduledEvent

### Current Problems (Before ADR)

- Business logic scattered between controllers and services (mixing concerns)
- Infrastructure dependencies (NestJS decorators) polluting domain entities
- Difficult to test domain logic without mocking external services
- High coupling between API endpoint and business rules
- No clear entry point for new requirements

## Alternatives Considered

### 1. Clean Architecture

- **Pros**: Cleaner than Layered, independent of frameworks
- **Cons**: Less explicit about domain modeling, fewer patterns for business rule management
- **Decision**: Not selected - Hexagonal provides more explicit ports/adapters metaphor

### 2. CQRS + Event Sourcing

- **Pros**: Excellent for complex domains, event replay for temporal queries
- **Cons**: Significant complexity overhead for MVP, requires extensive event modeling
- **Decision**: Not selected - Overkill for current MVP scope, but ADR-001 design enables future adoption

### 3. Layered Architecture (Monolith)

- **Pros**: Simple, quick to implement
- **Cons**: Monolithic growth, high coupling, difficult to isolate business logic
- **Decision**: Not selected - Does not meet scalability and testability requirements

### 4. Domain-Driven Design (Full)

- **Pros**: Enterprise standard, excellent for complex domains
- **Cons**: Heavy - requires Strategic (Bounded Contexts) AND Tactical (Entities, Value Objects) patterns
- **Decision**: Selected Tactical DDD only - Strategic DDD (Bounded Contexts) reserved for Phase 2

## Decision

**Implement Hexagonal Architecture + Domain-Driven Design (Tactical)** with three distinct layers:

### Layer 1: Domain Layer (Framework-Independent)

**Responsibility**: Encapsulate pure business logic

```
src/domain/
├── entities/          # Appointment, Doctor, ConsultingRoom
├── value-objects/     # AppointmentId, ConsultationTime
├── policies/          # OfficeHourPolicy, CapacityPolicy, ...
├── domain-events/     # AppointmentCreatedEvent, etc
├── types/             # Business type definitions
└── errors/            # Domain-specific exceptions
```

**Characteristics**:

- Zero dependencies on NestJS, Express, MongoDB, RabbitMQ
- Pure TypeScript/business logic
- Immutable (where possible) via Value Objects
- Business rules expressed as Policies or Entity methods
- Testable with plain Jest (no mocks of infrastructure)

### Layer 2: Application Layer (Use Case Orchestration)

**Responsibility**: Coordinate domain objects to fulfill use cases

```
src/application/
├── use-cases/         # CreateAppointmentUseCase, CancelAppointmentUseCase
├── dto/               # Input/Output data transfer objects
├── mappers/           # Domain ↔ DTO conversion
├── services/          # Application services orchestrating policies
└── ports/             # Port interfaces (outbound dependencies)
```

**Characteristics**:

- Orchestrates Domain layer objects
- Defines outbound ports (Repository, EventPublisher)
- Maps between Domain entities and DTOs
- Application-specific exceptions and error handling
- Single-responsibility: one use case per class

### Layer 3: Infrastructure Layer (Technical Implementation)

**Responsibility**: Implement ports and provide framework integration

```
src/infrastructure/
├── repositories/      # MongoDB implementations of Repository interface
├── event-publisher/   # RabbitMQ implementation of EventPublisher
├── formatters/        # NestJS decorators, middleware
├── external-services/ # Third-party API integrations
└── persistence/       # Database connection, migrations
```

**Characteristics**:

- Implements outbound port interfaces (Dependency Inversion)
- NestJS controllers are thin adapters (Hexagonal "adapters")
- Database schema and ORM configuration
- Message queue configuration
- External service clients

## Benefits

### + Domain Isolation

- Business logic completely independent of frameworks
- Can migrate NestJS → ExpressJS → Fastify without touching domain
- Testable without test containers or databases

### + Low Coupling

- Domain doesn't depend on Infrastructure (unidirectional dependency)
- Multiple adapters can implement same port (Hexagonal benefit)
- Easy to mock ports in Application layer tests

### + Scalability

- Foundation for future microservices decomposition
- Domain Events support async communication (ADR-005)
- Policies enable composition of business rules (ADR-003)

### + Clear Responsibility

- Each layer has single, well-defined purpose
- New developers understand architecture via folder structure
- Easy to locate where to implement new features

### + Enterprise Alignment

- Follows industry standards (Hexagonal, DDD)
- Enables SOLID principles (validated in DEBT_REPORT.md)
- Supports evolution path: Hexagonal → Microservices → DDD Strategic

## Tradeoffs

### - Additional Boilerplate

- **Mitigated by**: Code generation, templates
- **Example**: AppointmentRepository interface + MongoDB implementation + DTO mapping
- **Cost vs Benefit**: Upfront cost pays off in testability and maintainability

### - Steeper Learning Curve

- **Mitigated by**: Documentation (this ADR), code examples, pair programming
- **Requires**: Team training on Hexagonal and DDD Tactical patterns

### - More Files/Directories

- **Mitigated by**: Clear naming conventions, IDE navigation
- **Organization**: Logically grouped (use-cases, domain, infrastructure)

## Consequences

### Positive

1. **Domain Completeness**
   - Verified: Zero `@nestjs` imports in `src/domain/`
   - All business logic consolidated
   - Easier code review (domain vs infrastructure changes visible)

2. **Testability**
   - Unit tests for domain require no mocks
   - Example: Test `OfficeHourPolicy` directly without database
   - Coverage targets easily achievable

3. **SOLID Principles**
   - Single Responsibility: Each layer has one reason to change
   - Open/Closed: Add new policies without modifying existing ones (ADR-003)
   - Liskov Substitution: Policy implementations interchangeable
   - Interface Segregation: Domain defines minimal interfaces
   - Dependency Inversion: Domain depends on abstractions (ports), not concretions

4. **Future Evolution**
   - **Phase 2**: Add Bounded Contexts (Strategic DDD)
   - **Phase 3**: Decompose into microservices (each with own Hexagonal)
   - **Phase 4**: Add CQRS layer on top (Command/Query separation)

5. **Framework Agnostic**
   - Domain works with any HTTP framework
   - ORM replaceable (Mongoose → Prisma → TypeORM)
   - Message queue replaceable (RabbitMQ → Kafka → AWS SQS)

### Negative

1. **Indirection**
   - Ports require implementing interfaces
   - DTOs add mapping overhead
   - Slightly more code to follow logic flow
   - **Mitigation**: IDEs make navigation easy (Go to Definition)

2. **Initial Complexity**
   - More directories and files to understand
   - Requires discipline to maintain separation
   - **Mitigation**: Clear code guidelines (RULES.md)

3. **Performance Overhead** (Theoretical)
   - Mapping between Domain entities and DTOs adds cycles
   - **Mitigation**: Negligible for typical CRUD operations
   - **Reality**: Clarity gains outweigh micro-optimization costs

## Implementation Status

### Completed

- [x] Domain layer: Entities, Value Objects, Policies, Domain Events
- [x] Application layer: Use Cases, DTOs, Mappers
- [x] Infrastructure layer: Repositories, EventPublisher, NestJS adapters
- [x] SOLID principles validation (5/5 in DEBT_REPORT.md §2)
- [x] Test coverage >80% (jest coverage validated)
- [x] Documentation: Code examples, inline comments

### In progress

- [ ] Team training workshop on Hexagonal Architecture
- [ ] Code generation templates for new domains

### Future

- [ ] Strategic DDD: Bounded Contexts mapping
- [ ] Microservices: Service decomposition
- [ ] CQRS: Command/Query separation layer

## Related Decisions

- **[ADR-003](./ADR-003.md)**: Policy Pattern leverages Hexagonal layer separation
- **[ADR-005](./ADR-005.md)**: Domain Events enable inter-service communication
- **[DEBT_REPORT.md](../DEBT_REPORT.md)**: §1-2 (Domain + Application layers architecture)
- **[RULES.md](../agent-context/RULES.md)**: §2 (SOLID principles enforcement)

## References

### Foundational Books

- **Evans, E.** (2003). _Domain-Driven Design: Tackling Complexity in the Heart of Software_. Addison-Wesley.
  - Part I: Putting the Domain Model to Work
  - Part III: Refactoring Toward Deeper Insight

- **Cockburn, A.** (2005). _Hexagonal Architecture_. http://alistair.cockburn.us/Hexagonal+architecture
  - Original paper introducing Ports and Adapters

- **Vernon, V.** (2013). _Implementing Domain-Driven Design_. Addison-Wesley.
  - Chapter 4: Repositories
  - Chapter 8: Tactical Design Elements

- **Martin, R. C.** (2009). _Clean Architecture: A Craftsman's Guide to Software Structure and Design_. Prentice Hall.
  - Part III: Design Principles
  - Chapters 8-12: SOLID principles

### Code References

- **src/domain/entities/**: Plain TypeScript + domain logic
- **src/application/use-cases/**: Orchestration of domain + ports
- **src/infrastructure/repositories/**: Port implementations
- **backend/producer/**: Producer service (primary example)
- **backend/consumer/**: Consumer service (secondary adapter)

### Metrics

- Domain test coverage: >85%
- Infrastructure test coverage: >75%
- Application test coverage: >80%
- Total repository test coverage: >80%

## Approval

| Role              | Date       | Notes                              |
| ----------------- | ---------- | ---------------------------------- |
| Architecture Team | 2026-02-20 | Approved for MVP                   |
| Tech Lead         | 2026-02-20 | Validated against SOLID principles |
| QA Team           | 2026-02-20 | Supports testing strategy          |

---

**Document Version**: 1.0  
**Last Updated**: 2026-02-20  
**Next Review**: 2026-05-20 (Post-MVP)
