# ADR-003: Policy Pattern for Business Rules Evaluation

**Date**: 2026-02-20  
**Status**: ACCEPTED  
**Author**: Architecture Team  
**Supersedes**: N/A  
**Superseded by**: N/A

## Context

The appointment domain has numerous interdependent business rules that must be validated before an appointment can be created or modified:

### Identified Business Rules

1. **OfficeHourPolicy** - Appointments only during 8:00-18:00
2. **CapacityPolicy** - Doctor can't have >N appointments simultaneously
3. **DoctorAvailabilityPolicy** - Doctor scheduled for consultation
4. **ConsultingRoomPolicy** - Room must be available at requested time
5. **ConsultationDurationPolicy** - Minimum 15-minute slots
6. **PatientHistoryPolicy** - Can't exceed appointments/month
7. **NoticePolicy** - Must book ≥24 hours in advance
8. **ConflictPolicy** - Can't double-book same doctor/room

### Evolution Challenge

New institutions request custom rules:

- Hospital A: "No appointments on Saturdays"
- Hospital B: "Doctor must have 30-min buffer between patients"
- Hospital C: "Complex scheduling based on medical specialty"

Adding 3 custom validation rules per institution:

- Hard-coded if/else statements (200+ lines per rule)
- Monolithic validator class (2000+ lines, single responsibility violation)
- Modifying existing code for each new rule (violates Open/Closed Principle)

### Current State

```typescript
// Anti-pattern: Anti-pattern: Monolithic validation
class AppointmentValidator {
  validate(apt: Appointment): ValidationResult {
    // 8+ validation rules in one method
    if (apt.date.getHours() < 8) return fail("Outside hours");
    if (apt.doctor.appointments.length >= cap) return fail("Capacity exceeded");
    if (!apt.doctor.availability.includes(apt.date))
      return fail("Doctor unavailable");
    // ... 5 more rules
    return succeed();
  }
}

// Problem: Adding new rule = modify validator, violate OCP
```

## Alternatives Considered

### 1. Chain of Responsibility

```typescript
abstract class ValidationHandler {
  next?: ValidationHandler;

  handle(apt: Appointment): Result {
    const result = this.validate(apt);
    if (result.isErr()) return result;
    return this.next?.handle(apt) ?? Result.ok();
  }

  abstract validate(apt: Appointment): Result;
}

class OfficeHourHandler extends ValidationHandler {
  validate(apt: Appointment): Result {
    /* ... */
  }
}
```

**Pros**:

- Decoupled validation steps
- Easy order of execution

**Cons**

- Not reusable (tightly coupled to chain structure)
- Can only execute in sequence (no parallel evaluation)
- Semantically less clear (inheritance-based coupling)

**Decision**: Rejected - Less explicit than Policy

### 2. Spec Pattern

```typescript
abstract class Specification {
  abstract isSatisfiedBy(apt: Appointment): boolean;
  and(spec: Specification): Specification {
    /* ... */
  }
  or(spec: Specification): Specification {
    /* ... */
  }
  not(): Specification {
    /* ... */
  }
}

class OfficeHourSpec extends Specification {
  isSatisfiedBy(apt: Appointment): boolean {
    return apt.date.getHours() >= 8;
  }
}
```

**Pros**:

- Composable (can combine with AND/OR/NOT)
- Well-established pattern
- Boolean-based

**Cons**

- Only returns true/false (no error details)
- Complex composition syntax
- Less domain-cohesive

**Decision**: Rejected - Loses error message information

### 3. Decorator Pattern

```typescript
class ValidatedAppointment {
  constructor(private apt: Appointment) {}

  with(validator: Validator): ValidatedAppointment {
    /* ... */
  }
}
```

**Pros**:

- Adds responsibilities to objects dynamically

**Cons**

- Adds runtime wrapper overhead
- Less clear semantics
- Doesn't express "policy" concept explicitly

**Decision**: Rejected - Over-abstracts the concept

### 4. Policy Pattern

```typescript
interface ConsultationPolicy {
  evaluate(apt: Appointment): Result<void, string>;
}

class OfficeHourPolicy implements ConsultationPolicy {
  evaluate(apt: Appointment): Result<void, string> {
    const hour = apt.date.getHours();
    return hour >= 8 && hour <= 18
      ? Result.ok()
      : Result.err("Appointment outside office hours");
  }
}
```

**Pros**:

- Explicit "Policy" concept matches domain language
- Composable without complex syntax
- Returns detailed error messages
- Easy to test individually
- Extensible without modification (OCP)

**Decision**: Selected - Best fit for business rule management

## Decision

**Implement Policy Pattern** for evaluating business rules in the appointment domain.

### Pattern Definition

A **Policy** is a single, reusable business rule evaluator:

- Encapsulates one business rule
- Produces a `Result<void, ErrorMessage>`
- Framework-independent (domain layer)
- Easily composable in use cases

### Interface Definition

```typescript
// domain/policies/ConsultationPolicy.ts
export interface ConsultationPolicy {
  /**
   * Evaluates whether the given appointment satisfies this policy.
   *
   * @param appointment The appointment to evaluate
   * @returns Result.ok() if policy satisfied, Result.err(message) if not
   */
  evaluate(appointment: Appointment): Result<void, string>;

  /**
   * Human-readable name of this policy
   * @example "Office Hours Policy"
   */
  readonly name: string;

  /**
   * Policy severity (high = blocks appointment, low = warning)
   */
  readonly severity: "critical" | "high" | "medium" | "low";
}

export type PolicyResult = Result<void, string>;
```

### Policy Implementations

#### 1. Office Hour Policy

```typescript
// domain/policies/OfficeHourPolicy.ts

export class OfficeHourPolicy implements ConsultationPolicy {
  readonly name = "Office Hours Policy";
  readonly severity = "critical";

  private readonly OFFICE_START = 8; // 8:00 AM
  private readonly OFFICE_END = 18; // 6:00 PM

  evaluate(appointment: Appointment): PolicyResult {
    const hour = appointment.date.getHours();

    if (hour < this.OFFICE_START) {
      return Result.err(
        `Appointment at ${hour}:00 is before office opening (${this.OFFICE_START}:00)`,
      );
    }

    if (hour >= this.OFFICE_END) {
      return Result.err(
        `Appointment at ${hour}:00 is after office closing (${this.OFFICE_END}:00)`,
      );
    }

    return Result.ok();
  }
}
```

#### 2. Capacity Policy

```typescript
// domain/policies/CapacityPolicy.ts

export class CapacityPolicy implements ConsultationPolicy {
  readonly name = "Doctor Capacity Policy";
  readonly severity = "high";

  private readonly MAX_CONCURRENT = 3;

  evaluate(appointment: Appointment): PolicyResult {
    const concurrent = appointment.doctor.getAppointmentsAt(
      appointment.date,
    ).length;

    if (concurrent >= this.MAX_CONCURRENT) {
      return Result.err(
        `Doctor ${appointment.doctor.name} has maximum capacity (${this.MAX_CONCURRENT}) at this time`,
      );
    }

    return Result.ok();
  }
}
```

#### 3. Doctor Availability Policy

```typescript
// domain/policies/DoctorAvailabilityPolicy.ts

export class DoctorAvailabilityPolicy implements ConsultationPolicy {
  readonly name = "Doctor Availability Policy";
  readonly severity = "critical";

  evaluate(appointment: Appointment): PolicyResult {
    const isAvailable = appointment.doctor.availability.some((slot) =>
      slot.contains(appointment.date),
    );

    if (!isAvailable) {
      return Result.err(
        `Doctor ${appointment.doctor.name} is not available at ${appointment.date}`,
      );
    }

    return Result.ok();
  }
}
```

#### 4. Consulting Room Policy

```typescript
// domain/policies/ConsultingRoomPolicy.ts

export class ConsultingRoomPolicy implements ConsultationPolicy {
  readonly name = "Consulting Room Availability Policy";
  readonly severity = "high";

  evaluate(appointment: Appointment): PolicyResult {
    if (!appointment.room) {
      return Result.err("No consulting room assigned to appointment");
    }

    const isAvailable = appointment.room.getAvailability(
      appointment.date,
    ).isAvailable;

    if (!isAvailable) {
      return Result.err(
        `Room ${appointment.room.number} is not available at ${appointment.date}`,
      );
    }

    return Result.ok();
  }
}
```

#### 5. Notice Policy (Future Booking)

```typescript
// domain/policies/NoticePolicy.ts

export class NoticePolicy implements ConsultationPolicy {
  readonly name = "Advance Notice Policy";
  readonly severity = "medium";

  private readonly MIN_HOURS_ADVANCE = 24;

  evaluate(appointment: Appointment): PolicyResult {
    const now = new Date();
    const hoursDifference =
      (appointment.date.getTime() - now.getTime()) / (1000 * 60 * 60);

    if (hoursDifference < this.MIN_HOURS_ADVANCE) {
      const hoursAhead = Math.floor(hoursDifference);
      return Result.err(
        `Appointment must be booked at least ${this.MIN_HOURS_ADVANCE} hours in advance (currently ${hoursAhead} hours)`,
      );
    }

    return Result.ok();
  }
}
```

### Policy Composition in Use Cases

```typescript
// application/use-cases/CreateAppointmentUseCase.ts

@Injectable()
export class CreateAppointmentUseCase {
  constructor(
    private readonly appointmentRepository: AppointmentRepository,
    private readonly eventPublisher: EventPublisher,
  ) {}

  async execute(
    cmd: CreateAppointmentCommand,
  ): Promise<Result<AppointmentId, string>> {
    // 1. Create domain entity
    const appointmentOrErr = Appointment.create({
      date: cmd.date,
      doctor: cmd.doctor,
      room: cmd.room,
      patient: cmd.patient,
    });

    if (appointmentOrErr.isErr()) {
      return Result.err(appointmentOrErr.error);
    }

    const appointment = appointmentOrErr.value;

    // 2. Compose policies
    const policies: ConsultationPolicy[] = [
      new OfficeHourPolicy(),
      new CapacityPolicy(),
      new DoctorAvailabilityPolicy(),
      new ConsultingRoomPolicy(),
      new NoticePolicy(),
    ];

    // 3. Evaluate policies sequentially
    for (const policy of policies) {
      const result = policy.evaluate(appointment);

      if (result.isErr()) {
        return Result.err(`Policy "${policy.name}" failed: ${result.error}`);
      }
    }

    // 4. Save & publish event
    await this.appointmentRepository.save(appointment);

    for (const event of appointment.domainEvents) {
      await this.eventPublisher.publish(event);
    }

    return Result.ok(appointment.id);
  }
}
```

### Policy Injection (Flexible Composition)

```typescript
// Better: Inject policies for testability
@Injectable()
export class CreateAppointmentUseCase {
  constructor(
    private readonly appointmentRepository: AppointmentRepository,
    @Inject("CONSULTATION_POLICIES")
    private readonly policies: ConsultationPolicy[],
  ) {}

  async execute(cmd: CreateAppointmentCommand): Promise<Result> {
    const appointment = Appointment.create(cmd).value;

    for (const policy of this.policies) {
      const result = policy.evaluate(appointment);
      if (result.isErr()) {
        return Result.err(result.error);
      }
    }

    // ... rest of use case
  }
}

// NestJS Module Configuration
@Module({
  providers: [
    {
      provide: "CONSULTATION_POLICIES",
      useValue: [
        new OfficeHourPolicy(),
        new CapacityPolicy(),
        new DoctorAvailabilityPolicy(),
        new ConsultingRoomPolicy(),
        new NoticePolicy(),
      ],
    },
    CreateAppointmentUseCase,
  ],
})
export class AppointmentsModule {}
```

## Benefits and Consequences

### Positive consequences

1. **Open/Closed Principle**

   ```
   Open for extension: Add new policy = new class
   Closed for modification: No changes to existing code
   ```

   - Hospital A adds "WeekendPolicy" without touching domain
   - Hospital B adds "BufferPolicy" without affecting others

2. **Single Responsibility**
   - Each policy = ONE business rule
   - Easy to understand, test, maintain
   - ~50 lines per policy (not 500-line validator)

3. **Reusability**
   - Policy usable in multiple contexts
   - Example: OfficeHourPolicy used in:
     - CreateAppointmentUseCase
     - RescheduleAppointmentUseCase
     - ReserveTimeSlotUseCase
   - No code duplication

4. **Testability**

   ```typescript
   test("OfficeHourPolicy rejects outside hours", () => {
     const policy = new OfficeHourPolicy();
     const apt = Appointment.create({ date: new Date("2026-02-20 07:00") });

     const result = policy.evaluate(apt.value);

     expect(result.isErr()).toBe(true);
     expect(result.error).toContain("before office opening");
   });
   ```

   - No mocks needed
   - No database required
   - Complete isolation

5. **Clear Domain Language**
   - Domain language directly in code
   - "Policy" is a ubiquitous language concept
   - Non-technical stakeholders understand: "OfficeHourPolicy"

6. **Composability**
   - Chain multiple policies in order
   - Can prioritize (critical policies first)
   - Partial validation (check subset of policies)

   ```typescript
   const criticalPolicies = policies.filter((p) => p.severity === "critical");
   const validationResult = applyPolicies(criticalPolicies);
   ```

7. **Error Clarity**
   - Each policy returns specific error message
   - User knows exactly which rule failed and why
   - More helpful UI messages

### Negative consequences

1. **Initial Boilerplate**

   ```
   Creating new policy requires:
   - Interface implementation
   - Business logic
   - Unit tests
   - Documentation

   Cost: ~1 hour per policy (amortized across reuse)
   ```

2. **Policy Dependencies**

   ```
   What if a policy needs another service?

   class SMTPNotificationPolicy implements ConsultationPolicy {
     constructor(private emailService: EmailService) {}
     // ❓ But EmailService is infrastructure, not domain
   }
   ```

   **Mitigation**: Keep policies pure domain logic
   - Domain layer has no external dependencies
   - Complex validations move to Application layer

3. **Execution Order Matters**

   ```
   // Different execution order, different results:
   [OfficeHour, Capacity, Doctor].evaluate() // May pass
   [Doctor, OfficeHour, Capacity].evaluate()  // May fail earlier
   ```

   **Mitigation**: Document policy ordering, prioritize critical first

4. **Instance Creation**

   ```
   // Creating policies each time is wasteful
   const policies = [
     new OfficeHourPolicy(),
     new CapacityPolicy(),
     // ...
   ];
   ```

   **Mitigation**: Use dependency injection (see example above)

## Implementation Status

### Completed

- [x] ConsultationPolicy interface
- [x] Policy implementations: Office Hours, Capacity, Doctor Availability, Room, Notice
- [x] Policy composition in CreateAppointmentUseCase
- [x] Result<T, E> type for error handling
- [x] Unit tests for each policy (>85% coverage)
- [x] NestJS module configuration (dependency injection)

### In progress

- [ ] Policy registry/discovery (for multi-tenant scenarios)
- [ ] Conditional policy execution (if/else logic between policies)

### Future enhancements

- [ ] Policy priority/severity levels
- [ ] Async policy support (external system calls)
- [ ] Policy composition DSL (simpler creation of complex rules)
- [ ] Policy metrics/observability (which rules reject most)

## Related Decisions

- **[ADR-001](./ADR-001.md)**: Hexagonal Architecture provides layer separation enabling policies
- **[DEBT_REPORT.md](../DEBT_REPORT.md)**: §3 (Policy implementation details)
- **[RULES.md](../agent-context/RULES.md)**: §2 (OCP and SRP validation)

## References

### Design Pattern Books

- **Gang of Four.** (1994). _Design Patterns: Elements of Reusable Object-Oriented Software_. Addison-Wesley.
  - Strategy Pattern (similar concept)

- **Freeman, E. & Freeman, E.** (2004). _Head First Design Patterns_. O'Reilly.
  - Chapter: Strategy Pattern (comparison)

### Domain-Driven Design

- **Evans, E.** (2003). _Domain-Driven Design_. Addison-Wesley.
  - Chapter 5: A Model Expressed in Software (value objects, entities)

- **Vernon, V.** (2013). _Implementing Domain-Driven Design_. Addison-Wesley.
  - Chapter 4: Repository Pattern
  - Chapter 8: Value Objects

### Code References

- **src/domain/policies/**: All policy implementations
- **src/application/use-cases/**: Policy composition examples
- **test/domain/policies/**: Unit test examples
- **DEBT_REPORT.md §3**: Implementation details and metrics

### Metrics

- Average policy size: 40-60 lines
- Test coverage per policy: >90%
- Policy reusability: 3-5 use cases per policy
- Average policy evaluation time: <1ms

## Approval and Evolution

| Version | Date       | Status      | Notes                                       |
| ------- | ---------- | ----------- | ------------------------------------------- |
| 1.0     | 2026-02-20 | ACCEPTED    | MVP implementation with 5 core policies     |
| TBD     | TBD        | ENHANCEMENT | Add async policies for external validations |
| TBD     | TBD        | ENHANCEMENT | Policy orchestration DSL for complex rules  |

---

**Document Version**: 1.0  
**Last Updated**: 2026-02-20  
**Next Review**: 2026-05-20 (Post-MVP)
