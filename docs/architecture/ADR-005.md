# ADR-005: Domain Events for Inter-Service Communication

**Date**: 2026-02-20  
**Status**: ACCEPTED  
**Author**: Architecture Team  
**Supersedes**: N/A  
**Superseded by**: N/A

## Context

The appointment system consists of Producer and Consumer services that must communicate around significant business events:

### Business Events

1. **AppointmentCreatedEvent** → Trigger notifications, update availability
2. **AppointmentConfirmedEvent** → Send confirmation to patient/doctor
3. **AppointmentRescheduleEvent** → Free old slot, allocate new slot
4. **AppointmentCancelledEvent** → Free slot, send cancellation notice

### Current Challenge

```typescript
// Anti-pattern: Tight coupling without Domain Events
Producer Service:
class CreateAppointmentController {
  @Post('/appointments')
  async create(cmd) {
    const apt = await this.createAppointmentUseCase.execute(cmd);

    // Direct call - blocking, coupled, hard to extend
    await this.notificationService.notify(apt);       // Hard-coded
    await this.availabilityService.update(apt);       // Hard-coded
    await this.analyticsService.track(apt);           // Hard-coded

    return apt;
  }
}
```

Problems:

1. **Producer blocks** on Consumer operations
2. **Producer fails** if Consumer is down
3. **Hard-coded subscribers** (can't add new followers without changing Producer)
4. **Tight coupling** (Producer knows about all handlers)
5. **No audit trail** (what events triggered what actions?)

### Event-Driven Solution

```
Producer emits event →  RabbitMQ Queue  → Multiple independent subscribers
                              ↓
                    ┌─────────┼─────────┐
                    ↓         ↓         ↓
                Notification  Update   Analytics
                Service      Service   Service
```

Benefits:

- Producer doesn't block
- Subscribers independent
- Easy to add new subscribers
- Complete audit trail

## Alternatives Considered

### 1. Direct Service Calls (REST)

```typescript
// Producer calls Consumer directly
const response = await notificationService.notify(appointment);
```

**Pros**:

- Simple to understand
- Synchronous response

**Cons**

- Tight coupling
- Blocking calls (poor performance)
- Hard to scale consumers
- Cascading failures
- Related: ADR-002

**Decision**: Rejected - Fundamental problem Domain Events solve

### 2. Sagas (Orchestration Pattern)

```typescript
// Orchestrator manages flow
class AppointmentSaga {
  async createAppointment(cmd) {
    const apt = await this.appointmentService.create(cmd);
    const notified = await this.notificationService.notify(apt);
    const updated = await this.availabilityService.update(apt);
    return { apt, notified, updated };
  }
}
```

**Pros**:

- Clear sequence flow
- Orchestrated compensation (rollback)

**Cons**

- Centralized orchestrator = bottleneck
- Still requires service coordination
- Compensating transactions complexity
- New subscribers still require Saga changes

**Decision**: Rejected - Events provide cleaner decoupling

### 3. CQRS (Command Query Responsibility Segregation)

```typescript
// Separate command and query models
class CreateAppointmentCommand { /* ... */ }
class AppointmentByDoctorQuery { /* ... */ }

// Events bridge command and query
AppointmentCreatedEvent → Update read model
```

**Pros**:

- Powerful for complex domains
- Separate read/write optimization

**Cons**

- Heavy for MVP
- Requires event store
- Complex to implement and maintain

**Decision**: Rejected - Overkill for current requirements

### 4. Domain Events

```typescript
// Producer emits event
class CreateAppointmentUseCase {
  async execute(cmd) {
    const apt = Appointment.create(cmd).value;
    apt.addDomainEvent(new AppointmentCreatedEvent(apt.id));
    await this.appointmentRepository.save(apt); // Events published separately
    return apt;
  }
}

// Multiple independent subscribers
@MessagePattern('appointment.created')
async handleNotification(event) { /* ... */ }

@MessagePattern('appointment.created')
async handleAvailabilityUpdate(event) { /* ... */ }

@MessagePattern('appointment.created')
async handleAnalytics(event) { /* ... */ }
```

**Pros**:

- Decoupled (pub/sub pattern)
- Scalable (many subscribers)
- Auditable (all events tracked)
- Extensible (add subscribers without changing Producer)

**Decision**: Selected - Industry standard for distributed systems

## Decision

**Implement Domain Events** as the primary mechanism for communication between Producer and Consumer services. Events are:

- Published to RabbitMQ (ADR-002)
- Consumed by independent handlers
- Persisted for audit trail
- Designed following domain language

### What is a Domain Event?

A Domain Event represents something that happened in the domain that other parts (possibly in other services) care about.

```typescript
// A fact that happened
"An appointment was created for patient John Doe with doctor Sarah Smith
at 2026-02-20 10:30 AM in room 101"

↓ Expressed as Event

class AppointmentCreatedEvent extends DomainEvent {
  readonly eventName = 'appointment.created';
  readonly version = 1;

  constructor(
    readonly appointmentId: AppointmentId,
    readonly patientId: PatientId,
    readonly doctorId: DoctorId,
    readonly appointmentDate: DateTime,
    readonly roomId: RoomId,
    readonly createdAt: Date
  ) {
    super();
  }
}
```

### Domain Event Base Class

```typescript
// domain/events/DomainEvent.ts

export abstract class DomainEvent {
  /**
   * Unique event type identifier (e.g., 'appointment.created')
   */
  abstract readonly eventName: string;

  /**
   * Event format version (for schema evolution)
   */
  abstract readonly version: number;

  /**
   * Aggregate ID (entity that triggered the event)
   */
  abstract readonly aggregateId: string | object;

  /**
   * When this event occurred
   */
  readonly occurredAt: Date = new Date();

  /**
   * Unique event ID (for idempotency)
   */
  readonly eventId: string = uuid();
}
```

### Complete Event Examples

#### 1. AppointmentCreatedEvent

```typescript
// domain/events/AppointmentCreatedEvent.ts

export class AppointmentCreatedEvent extends DomainEvent {
  readonly eventName = "appointment.created";
  readonly version = 1;

  constructor(
    readonly appointmentId: AppointmentId,
    readonly patientId: PatientId,
    readonly patientEmail: Email,
    readonly doctorId: DoctorId,
    readonly doctorName: DoctorName,
    readonly appointmentDate: DateTime,
    readonly roomId: RoomId,
    readonly createdAt: Date,
  ) {
    super();
  }

  /**
   * Payload for RabbitMQ serialization
   */
  toPayload() {
    return {
      eventId: this.eventId,
      eventName: this.eventName,
      version: this.version,
      occurredAt: this.occurredAt.toISOString(),
      aggregateId: this.appointmentId.value,
      data: {
        appointmentId: this.appointmentId.value,
        patientId: this.patientId.value,
        patientEmail: this.patientEmail.value,
        doctorId: this.doctorId.value,
        doctorName: this.doctorName.value,
        appointmentDate: this.appointmentDate.value.toISOString(),
        roomId: this.roomId.value,
        createdAt: this.createdAt.toISOString(),
      },
    };
  }

  /**
   * Reconstruct event from RabbitMQ message
   */
  static fromPayload(payload: any): AppointmentCreatedEvent {
    return new AppointmentCreatedEvent(
      new AppointmentId(payload.data.appointmentId),
      new PatientId(payload.data.patientId),
      new Email(payload.data.patientEmail),
      new DoctorId(payload.data.doctorId),
      new DoctorName(payload.data.doctorName),
      new DateTime(new Date(payload.data.appointmentDate)),
      new RoomId(payload.data.roomId),
      new Date(payload.data.createdAt),
    );
  }
}
```

#### 2. AppointmentCancelledEvent

```typescript
export class AppointmentCancelledEvent extends DomainEvent {
  readonly eventName = "appointment.cancelled";
  readonly version = 1;

  constructor(
    readonly appointmentId: AppointmentId,
    readonly doctorId: DoctorId,
    readonly roomId: RoomId,
    readonly appointmentDate: DateTime,
    readonly cancelledAt: Date,
    readonly reason: CancellationReason,
  ) {
    super();
  }

  toPayload() {
    return {
      eventId: this.eventId,
      eventName: this.eventName,
      version: this.version,
      occurredAt: this.occurredAt.toISOString(),
      aggregateId: this.appointmentId.value,
      data: {
        appointmentId: this.appointmentId.value,
        doctorId: this.doctorId.value,
        roomId: this.roomId.value,
        appointmentDate: this.appointmentDate.value.toISOString(),
        cancelledAt: this.cancelledAt.toISOString(),
        reason: this.reason.value,
      },
    };
  }
}
```

### Publishing Events in Use Cases

```typescript
// application/use-cases/CreateAppointmentUseCase.ts

@Injectable()
export class CreateAppointmentUseCase {
  constructor(
    private readonly appointmentRepository: AppointmentRepository,
    private readonly eventPublisher: EventPublisher,
    private readonly appointmentPolicies: ConsultationPolicy[],
  ) {}

  async execute(
    command: CreateAppointmentCommand,
  ): Promise<Result<CreateAppointmentResponse, string>> {
    // 1. Recreate aggregate (Appointment entity)
    const appointmentOrErr = Appointment.create({
      patientId: new PatientId(command.patientId),
      doctorId: new DoctorId(command.doctorId),
      date: new DateTime(command.date),
      roomId: new RoomId(command.roomId),
    });

    if (appointmentOrErr.isErr()) {
      return Result.err(appointmentOrErr.error);
    }

    const appointment = appointmentOrErr.value;

    // 2. Evaluate policies
    for (const policy of this.appointmentPolicies) {
      const result = policy.evaluate(appointment);
      if (result.isErr()) {
        return Result.err(result.error);
      }
    }

    // 3. Save aggregate (with domain events attached)
    await this.appointmentRepository.save(appointment);

    // 4. Publish all domain events
    //    Events are attached to aggregate during creation
    const events = appointment.domainEvents;
    for (const event of events) {
      // EventPublisher sends to RabbitMQ (ADR-002)
      await this.eventPublisher.publish(event);
    }

    // 5. Return DTO (clearing internal domain events)
    appointment.clearDomainEvents();

    return Result.ok(new CreateAppointmentResponse(appointment.id.value));
  }
}
```

### Handling Events (Consumer Service)

```typescript
// infrastructure/event-handlers/AppointmentCreatedEventHandler.ts

@Injectable()
export class AppointmentCreatedEventHandler {
  constructor(
    private readonly notificationService: NotificationService,
    private readonly availabilityService: AvailabilityService,
    private readonly auditLog: AuditLog,
  ) {}

  /**
   * NestJS Message Handler
   * Triggered when appointment.created event arrives from RabbitMQ
   */
  @MessagePattern("appointment.created")
  async handle(payload: any): Promise<void> {
    // 1. Reconstruct domain event from RabbitMQ payload
    const event = AppointmentCreatedEvent.fromPayload(payload);

    // 2. Handle side effects
    try {
      // Send notification to patient
      await this.notificationService.notifyPatient(
        event.patientEmail.value,
        `Appointment confirmed for ${event.appointmentDate.toString()}`,
      );

      // Send notification to doctor
      await this.notificationService.notifyDoctor(
        event.doctorId.value,
        `New appointment with patient ${event.patientId.value}`,
      );

      // Update doctor availability
      await this.availabilityService.markSlotUnavailable(
        event.doctorId.value,
        event.appointmentDate.value,
      );

      // Audit log (compliance)
      await this.auditLog.log({
        eventId: event.eventId,
        eventName: event.eventName,
        aggregateId: event.appointmentId.value,
        timestamp: event.occurredAt,
        action: "appointment_created",
      });
    } catch (error) {
      // Log error - RabbitMQ will retry
      console.error(`Error handling appointment.created: ${error.message}`);
      throw error; // Rethrow to trigger RabbitMQ retry
    }
  }
}
```

### Aggregate Pattern (Event Container)

```typescript
// domain/entities/Appointment.ts

export class Appointment extends AggregateRoot {
  private domainEvents: DomainEvent[] = [];

  static create(props: CreateAppointmentProps): Result<Appointment> {
    const apt = new Appointment(props);

    // Add domain event when created
    apt.addDomainEvent(
      new AppointmentCreatedEvent(
        apt.id,
        apt.patientId,
        apt.patientEmail,
        apt.doctorId,
        apt.doctorName,
        apt.date,
        apt.roomId,
        new Date(),
      ),
    );

    return Result.ok(apt);
  }

  cancel(reason: CancellationReason): Result<void> {
    // Validation...

    this.status = "cancelled";

    // Add domain event when cancelled
    this.addDomainEvent(
      new AppointmentCancelledEvent(
        this.id,
        this.doctorId,
        this.roomId,
        this.date,
        new Date(),
        reason,
      ),
    );

    return Result.ok();
  }

  addDomainEvent(event: DomainEvent): void {
    this.domainEvents.push(event);
  }

  getDomainEvents(): DomainEvent[] {
    return this.domainEvents;
  }

  clearDomainEvents(): void {
    this.domainEvents = [];
  }
}
```

## Idempotency Pattern

Events might be published multiple times due to network failures. Handlers must be idempotent:

```typescript
// Correct: Idempotent handler
@MessagePattern('appointment.created')
async handle(payload: any): Promise<void> {
  const event = AppointmentCreatedEvent.fromPayload(payload);

  // Check if already processed (using eventId)
  const exists = await this.eventLog.findByEventId(event.eventId);
  if (exists) {
    // Already processed this event - idempotent return
    return;
  }

  // Process event...
  await this.doWork(event);

  // Record that we processed this event
  await this.eventLog.save({ eventId: event.eventId });
}

// Anti-pattern: Wrong: Not idempotent
@MessagePattern('appointment.created')
async handle(payload: any): Promise<void> {
  const event = AppointmentCreatedEvent.fromPayload(payload);

  // No check - if retried, creates duplicate notification
  await this.notificationService.notify(event.patientEmail);
}
```

## Benefits and Consequences

### Positive consequences

1. **Complete Decoupling**
   - Producer doesn't know about Consumer handlers
   - Consumer doesn't depend on Producer
   - Any service can publish/consume events

2. **Unlimited Subscribers**

   ```
   appointment.created event triggers:
   ├─ NotificationHandler (send emails)
   ├─ AvailabilityHandler (update calendar)
   ├─ AnalyticsHandler (collect metrics)
   ├─ AuditHandler (compliance logging)
   ├─ ExternalSyncHandler (3rd-party APIs)
   └─ [Future handler] (no Producer change)
   ```

3. **Auditability**
   - Every event recorded with eventId
   - Complete timeline of changes
   - Debugging distributed flow becomes tractable

4. **Temporal Decoupling**
   - Producer doesn't wait for handlers
   - Consumer processes at own pace
   - Systems independent timelines

5. **Supports Business Growth**
   - New institution = new handlers (no Producer change)
   - Custom business rules = new subscribers
   - Evolution without regression risk

6. **Foundation for Advanced Patterns**
   - Event Sourcing (store all events as history)
   - CQRS (separate read/write models)
   - Time-travel debugging (replay events)

### Negative consequences

1. **Eventual Consistency**

   ```
   Time T=0:   Appointment created
   Time T=1ms: Notification sent (lag)

   User reads data at T=0.5ms → Notification not sent yet

   Mitigation: Acceptable for appointment system (lag < 1 second)
   ```

2. **Distributed Debugging**

   ```
   Request flow no longer linear

   POST /appointments (Producer)
   └─→ appointment.created event
       └─→ RabbitMQ queue
           └─→ Consumer handler processes async

   Mitigation: Correlation IDs in logs, distributed tracing tools
   ```

3. **Idempotency Required**

   ```
   Network failure = retry = duplicate event

   Handler must detect: "I've already processed this (eventId)"

   Mitigation: Event deduplication with eventId
   ```

4. **Schema Evolution**

   ```
   Version 1: { appointmentId, doctorId, date }
   Time passes...
   Version 2: { appointmentId, doctorId, date, roomId, insurance }

   Old handlers don't know about insurance field

   Mitigation: Version field in event + backwards-compatible parsing
   ```

5. **Infra Complexity**

   ```
   Requires: RabbitMQ, event serialization, consumer management

   Mitigation: docker-compose provides infrastructure
   ```

## Implementation Status

### Completed

- [x] DomainEvent base class
- [x] AppointmentCreatedEvent implementation
- [x] AppointmentCancelledEvent implementation
- [x] Aggregate pattern with domain events
- [x] EventPublisher interface and RabbitMQ implementation
- [x] Consumer handlers (@MessagePattern)
- [x] Idempotency via eventId tracking
- [x] Event serialization/deserialization
- [x] Integration tests (event flow validation)

### In progress

- [ ] Event schema versioning policy
- [ ] Dead-letter queue handler for failed events

### Future enhancements

- [ ] Event Sourcing (store all events as history)
- [ ] Event replay capability
- [ ] Saga pattern for distributed transactions
- [ ] Event projections (read model building)

## Related Decisions

- **[ADR-002](./ADR-002.md)**: RabbitMQ provides event publishing infrastructure
- **[ADR-001](./ADR-001.md)**: Hexagonal Architecture enables event publishing port
- **DEBT_REPORT.md §2**: A-05 Domain Event Architecture

## References

### Domain-Driven Design with Events

- **Vernon, V.** (2013). _Implementing Domain-Driven Design_. Addison-Wesley.
  - Chapter 2: Domains, Subdomains, and Bounded Contexts
  - Chapter 10: Aggregates (with domain events)

- **Evans, E.** (2003). _Domain-Driven Design: Tackling Complexity_. Addison-Wesley.
  - Part III: Refactoring Toward Deeper Insight

### Event-Driven Architecture

- **Newman, S.** (2015). _Building Microservices: Designing Fine-Grained Systems_. O'Reilly.
  - Chapter 5: Splitting the Monolith
  - Chapter 7: Testing

- **Richardson, C.** (2018). _Microservices Patterns_. Manning.
  - Pattern: Event Sourcing
  - Pattern: Saga (distributed transactions)

### Code References

- **src/domain/events/**: Event definitions
- **src/application/use-cases/**: Event publication
- **src/infrastructure/event-publisher/**: RabbitMQ integration
- **backend/consumer/src/**: Event handlers

### Metrics

- Event serialization: <1ms
- Publishing latency: <10ms
- Handler processing: <100ms (median)
- Event delivery guarantee: At-least-once

## Approval and Evolution

| Version | Date       | Status      | Notes                                  |
| ------- | ---------- | ----------- | -------------------------------------- |
| 1.0     | 2026-02-20 | ACCEPTED    | MVP implementation with basic events   |
| TBD     | TBD        | ENHANCEMENT | Add Event Sourcing storage             |
| TBD     | TBD        | ENHANCEMENT | Add Saga pattern for complex workflows |

---

**Document Version**: 1.0  
**Last Updated**: 2026-02-20  
**Next Review**: 2026-05-20 (Post-MVP)
