# ADR-004: MongoDB for Persistence

**Date**: 2026-02-20  
**Status**: ACCEPTED  
**Author**: Architecture Team  
**Version**: 1.0

---

## 1. Context

The system needs persistent storage for:

- Core appointment data (ID, date, patient, doctor, room)
- Metadata (custom fields, preferences, notes)
- Audit trail (creation/modification timestamps)
- Query patterns (date range, doctor, patient, status)

### Key Requirements

1. **Schema Flexibility**: New institutions add custom fields
2. **Query Performance**: Fast availability searches (1-month range)
3. **Scalability**: Growth from MVP → 1M appointments
4. **Transactions**: Atomic appointment creation
5. **Self-Hosted**: Client requires on-premise deployment

---

## 2. Decision

**Use MongoDB** with Mongoose ODM for appointment persistence

### Document Structure

```json
{
  \"_id\": ObjectId,
  \"appointmentId\": \"apt-001\",
  \"patientId\": \"pat-123\",
  \"patientName\": \"John Doe\",
  \"doctorId\": \"doc-456\",
  \"doctorName\": \"Dr. Smith\",
  \"consultationRoomId\": \"room-789\",
  \"date\": ISODate(\"2026-02-25T14:00:00Z\"),
  \"status\": \"confirmed\",
  \"notes\": \"Patient has allergy to penicillin\",
  \"metadata\": {
    \"insuranceCode\": \"INS-123\",
    \"referralNumber\": \"REF-2026-001\",
    \"customFields\": {}
  },
  \"createdAt\": ISODate(\"2026-02-20T10:00:00Z\"),
  \"updatedAt\": ISODate(\"2026-02-20T10:00:00Z\")
}
```

### Index Strategy

```typescript
// Single indexes
schema.index({ patientId: 1 });
schema.index({ doctorId: 1 });
schema.index({ status: 1 });
schema.index({ date: 1 });

// Compound indexes
schema.index({ doctorId: 1, date: 1 }); // Doctor schedule
schema.index({ status: 1, createdAt: -1 }); // Recent appointments
```

---

## 3. Alternatives Considered

### Alternative 1: PostgreSQL

- **Pros**: ACID, mature, powerful JOINs
- **Cons**: Rigid schema, migrations difficult, overkill for document data
- **Decision**: Rejected - Schema flexibility needed

### Alternative 2: Firebase Firestore

- **Pros**: Managed, flexible schema
- **Cons**: Vendor lock-in (Google), expensive at scale, cloud-only
- **Decision**: Rejected - Client wants self-hosted

### Alternative 3: Amazon DynamoDB

- **Pros**: Scalable, managed
- **Cons**: AWS-only, limited query flexibility, expensive
- **Decision**: Rejected - Vendor lock-in

### Alternative 4: MongoDB

- **Pros**: Flexible schema, rich queries, self-hosted option, mature
- **Cons**: Requires index management, eventual consistency
- **Decision**: Selected - Best fit

---

## 4. Benefits and Consequences

### Positive consequences

1. **Schema Flexibility**
   - Add fields without migration
   - Hospital A adds \"emergencyContact\" → no ALTER TABLE
   - Backward compatible with old documents

2. **Developer Experience**
   - JSON documents = natural JavaScript
   - Minimal impedance mismatch
   - Fast prototyping

3. **Query Performance**
   - Range queries for availability (date $gte, $lt)
   - Aggregation pipeline for analytics
   - Text search on notes
   - Proper indexes = <50ms for complex queries

4. **Scalability**
   - Single instance for MVP
   - Replica set for HA (Phase 2)
   - Sharding for horizontal scaling (Phase 3)

### Negative consequences

1. **Eventual Consistency**
   - Replica set lag: leader ahead of followers
   - **Mitigation**: Read from primary, acceptable for appointment system

2. **Manual Index Management**
   - Wrong indexes = slow queries
   - **Mitigation**: Performance testing in schema design phase

3. **Storage Overhead**
   - JSON format uses more space than normalized SQL
   - **Mitigation**: Compression, archive old data

4. **No Referential Integrity**
   - Orphaned documents possible
   - **Mitigation**: Application-level validation

---

## 5. Implementation

### Mongoose Schema

```typescript
@Schema({ timestamps: true })
export class AppointmentSchema extends Document {
  @Prop({ required: true, unique: true })
  appointmentId: string;

  @Prop({ required: true, index: true })
  patientId: string;

  @Prop({ required: true, index: true })
  doctorId: string;

  @Prop({ required: true, index: true })
  date: Date;

  @Prop({
    enum: ["pending", "confirmed", "completed", "cancelled"],
    default: "pending",
    index: true,
  })
  status: string;

  @Prop({ type: Object, default: {} })
  metadata: Record<string, any>;
}
```

### Docker Configuration

```yaml
mongodb:
  image: mongo:6.0
  environment:
    MONGO_INITDB_DATABASE: appointment_db
  volumes:
    - mongo_data:/data/db
  healthcheck:
    test: echo 'db.runCommand(\"ping\").ok' | mongosh
    interval: 30s
```

---

## 6. Performance Targets

| Operation                    | Target | Achieved |
| ---------------------------- | ------ | -------- |
| Find by ID                   | <1ms   | Yes       |
| Date range query (1000 docs) | <10ms  | Yes       |
| Doctor schedule query        | <15ms  | Yes       |
| Aggregation (daily stats)    | <50ms  | Yes       |

---

## 7. Related Decisions

- **[ADR-001](./ADR-001.md)**: Hexagonal Architecture (abstracts persistence)

---

**Document Version**: 1.0  
**Last Updated**: 2026-02-20  
**Next Review**: 2026-05-20
