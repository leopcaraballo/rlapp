# ADR-002: Event-Driven Architecture + RabbitMQ for Inter-Service Communication

**Date**: 2026-02-20  
**Status**: ACCEPTED  
**Author**: Architecture Team  
**Supersedes**: N/A  
**Superseded by**: N/A

## Context

The appointment management system consists of two independent services with distinct responsibilities:

- **Producer Service**: REST API managing appointment creation, updates, and queries
- **Consumer Service**: Background workers processing notifications, availability updates, and side effects

### Problem Statement

When an appointment is created in the Producer service, the Consumer service needs to:

1. Update doctor availability for future appointments
2. Send notifications (email, SMS) to patient and doctor
3. Log audit trail for compliance
4. Synchronize with external calendar systems

### Coupling Challenge

**Tight Coupling (Anti-pattern: Synchronous REST)**:

```
Producer → HTTP request → Consumer
           (wait for response)
```

Problems:

- Producer blocked waiting for Consumer response ➜ Poor user experience
- If Consumer is down ➜ Producer fails ➜ Appointment creation fails
- Hard to add new subscribers (notifications, analytics) without modifying Producer
- Cascading failures (one slow service slows entire system)

**Loose Coupling (Recommended: Event-Driven)**:

```
Producer → Domain Event → Message Queue → Multiple Consumers
           (fire and forget)
```

Benefits:

- Producer doesn't wait for response ➜ Fast user experience
- Consumer down ➜ Messages queue ➜ Consumer processes when ready
- Easy to add new subscribers without changing Producer
- Failures isolated (one consumer's slow processing doesn't block others)

### Scale Requirements

Current state:

- ~100-200 appointments/week
- Single instance of each service

Future state:

- Potential for 10x-100x growth
- Multiple Consumer workers needed to handle load
- Need horizontal scalability

## Alternatives Considered

### 1. Synchronous REST API Calls

```typescript
// Producer creates appointment, then waits for Consumer
const appointment = await createAppointment(cmd);
const updatedStatus = await consumerService.processAppointment(appointment);
await saveAppointment({ ...appointment, ...updatedStatus });
```

**Pros**:

- Simple to implement
- Direct request/response pattern
- Easy to debug (synchronous flow)

**Cons**

- Tight coupling between services
- Producer fails if Consumer is unavailable
- Blocks user waiting for all side effects
- Cannot horizontally scale Consumer easily
- Single point of failure

**Decision**: Rejected - Does not meet scalability and resilience requirements

### 2. REST Webhooks

```typescript
// Producer calls Consumer webhook endpoint
await fetch("http://consumer/webhooks/appointment-created", appointment);
```

**Pros**:

- Slightly decoupled (Consumer doesn't need to poll)
- Still relatively simple

**Cons**

- Still synchronous (blocks Producer)
- Retry logic needed if Consumer fails
- Different webhook standard per integration
- Difficult with multiple subscribers

**Decision**: Rejected - Still synchronous, doesn't scale

### 3. Kafka

```yaml
# Docker-compose
kafka:
  image: confluentinc/cp-kafka:latest
  environment:
    KAFKA_BROKER_ID: 1
```

**Pros**:

- Industry standard for high-throughput systems
- Excellent for event streaming
- Built-in replication and fault tolerance
- Perfect for data pipelines

**Cons**

- Operational complexity (cluster management)
- Resource overhead (requires Zookeeper/KRaft)
- Overkill for MVP (appointment system not a data streaming platform)
- Steeper learning curve
- Deployment complexity

**Decision**: Rejected - Over-engineered for current requirements

### 4. Redis Pub/Sub

```typescript
// Publisher
redis.publish("appointment:created", JSON.stringify(event));

// Subscriber
redis.subscribe("appointment:created", handleEvent);
```

**Pros**:

- Simple implementation
- Low latency
- Already familiar to JavaScript developers

**Cons**

- No message persistence (messages lost if no subscribers)
- Not designed for durable queues
- Limited by Redis memory
- Doesn't guarantee delivery

**Decision**: Rejected - Reliability requirements need message persistence

### 5. AWS SQS / SNS

```typescript
// Send to queue
await sqs.sendMessage({ QueueUrl: url, MessageBody: event });

// Consume from queue
const messages = await sqs.receiveMessage({ QueueUrl: url });
```

**Pros**:

- Managed service (no ops overhead)
- Built-in scalability
- Reliable delivery guarantees

**Cons**

- Vendor lock-in to AWS
- Extra latency (network calls to AWS)
- Cost concerns for MVP
- Requires AWS infrastructure setup

**Decision**: Rejected - Prefer open-source, self-hosted for MVP

### 6. RabbitMQ

```yaml
# Docker-compose
rabbitmq:
  image: rabbitmq:3.12-management
  ports:
    - "5672:5672" # AMQP
    - "15672:15672" # Management UI
```

**Pros**:

- Lightweight yet robust
- Excellent reliability (AMQP protocol)
- Message persistence to disk
- Dead-Letter Queue (DLQ) support
- Flexible routing (direct, topic, fanout exchanges)
- Easy to deploy (Docker)
- Ideal for MVP → Production transition

**Cons**:

- Requires operational management
- Memory usage if queue grows very large
- Need to learn AMQP protocol basics

**Decision**: Selected - Best fit for MVP with production viability

## Decision

**Implement Event-Driven Architecture using RabbitMQ** as the message broker for inter-service communication.

### Architecture Overview

```
┌─────────────────────────────────┐
│   Producer Service              │
│   ┌─────────────────────────┐   │
│   │ CreateAppointmentUseCase│   │
│   └────────────┬────────────┘   │
│                │                 │
│        Creates Domain Event      │
│                │                 │
│   ┌────────────▼────────────┐   │
│   │ EventPublisher          │   │
│   │ (AMQP RabbitMQ)         │   │
│   └────────────┬────────────┘   │
└────────────────┼─────────────────┘
                 │
        ┌────────▼─────────┐
        │   RabbitMQ       │
        │   Exchange:      │
        │ appointments.ex  │
        └────────┬─────────┘
                 │
        ┌────────┴────────────┐
        │                     │
        │        Queue        │
        │ apt.created.queue   │
        │                     │
        └────────┬────────────┘
                 │
    ┌────────────┴──────────────┐
    │                           │
┌───▼──────────┐      ┌────────▼──────┐
│   Consumer   │      │  Other        │
│   Service    │      │  Handlers     │
│ (Notification│      │ (Analytics,   │
│ +Updates)    │      │  Audit, etc)  │
└──────────────┘      └───────────────┘
```

### Core Components

#### 1. Message Format (Domain Event)

```typescript
class AppointmentCreatedEvent extends DomainEvent {
  constructor(
    appointmentId: AppointmentId,
    patientEmail: Email,
    doctorId: DoctorId,
    appointmentDate: DateTime,
    createdAt: Date,
  ) {
    super("appointment.created");
    this.aggregateId = appointmentId;
    this.timestamp = createdAt;
    this.version = 1;
    this.payload = { patientEmail, doctorId, appointmentDate };
  }
}
```

#### 2. Event Publisher (Infrastructure)

```typescript
// Implements Application layer port
@Injectable()
export class RabbitMQEventPublisher implements EventPublisher {
  async publish(event: DomainEvent): Promise<void> {
    const channel = await this.connection.createChannel();

    const exchange = "appointments.ex";
    const routingKey = event.eventName.toLowerCase(); // 'appointment.created'

    await channel.assertExchange(exchange, "topic", { durable: true });

    channel.publish(exchange, routingKey, Buffer.from(JSON.stringify(event)), {
      persistent: true,
      contentType: "application/json",
    });
  }
}
```

#### 3. Event Consumer (Infrastructure)

```typescript
// Consumer service subscribes to events
@MessagePattern('appointment.created')
async handleAppointmentCreated(event: AppointmentCreatedEvent) {
  // 1. Update doctor availability
  await this.availabilityService.updateAvailability(
    event.payload.doctorId,
    event.payload.appointmentDate
  );

  // 2. Send notification
  await this.notificationService.notifyPatient(
    event.payload.patientEmail
  );

  // 3. Log audit
  await this.auditLog.log({
    event: 'appointment.created',
    appointmentId: event.aggregateId,
    timestamp: event.timestamp
  });
}
```

#### 4. Docker Compose Configuration

```yaml
rabbitmq:
  image: rabbitmq:3.12-management
  environment:
    RABBITMQ_DEFAULT_USER: guest
    RABBITMQ_DEFAULT_PASS: guest
  ports:
    - "5672:5672" # AMQP protocol
    - "15672:15672" # Web management UI
  volumes:
    - rabbitmq_data:/var/lib/rabbitmq
  healthcheck:
    test: rabbitmq-diagnostics ping
    interval: 30s
    timeout: 10s
    retries: 5
```

## Configuration Details

### Exchange Configuration

```typescript
const EXCHANGE_CONFIG = {
  name: "appointments.ex",
  type: "topic", // Flexible routing: 'appointment.created', 'appointment.event'
  durable: true, // Persist exchange definition
  autoDelete: false,
};
```

### Queue Configuration

```typescript
const QUEUE_CONFIG = {
  name: "apt.notifications.queue",
  durable: true, // Persist messages
  exclusive: false, // Multiple consumers
  autoDelete: false,
  maxLength: 10000, // Prevent unbounded growth
  arguments: {
    "x-dead-letter-exchange": "DLX",
    "x-dead-letter-routing-key": "apt.notifications.dlq",
  },
};
```

### Binding

```typescript
// Queue 'apt.notifications.queue' receives messages
// matching routing key 'appointment.*'
channel.bindQueue(
  "apt.notifications.queue",
  "appointments.ex",
  "appointment.*",
  {},
);
```

## Benefits and Consequences

### Positive consequences

1. **Complete Decoupling**
   - Producer doesn't depend on Consumer running
   - Consumer doesn't need to know about Producer
   - Easy to replace either service

2. **Temporal Decoupling**
   - Producer publishes and returns immediately
   - Consumer can process at its own pace
   - Natural backpressure handling

3. **Unlimited Subscribers**

   ```
   appointment.created event can trigger:
   ├─ Notification handler (send emails)
   ├─ Availability updater (update calendar)
   ├─ Analytics collector (track metrics)
   ├─ Audit logger (compliance)
   └─ External system syncer (calendar APIs)

   Add new handler = new queue binding (no code changes)
   ```

4. **Failure Resilience**
   - Message persisted to disk
   - If Consumer crashes mid-processing, message requeued
   - Dead-Letter Queue catches problematic messages
   - System continues functioning

5. **Scalability**
   - Multiple Consumer instances can process same queue
   - Load balanced automatically
   - Messages processed in parallel
   - Throughput increases with more workers

6. **Auditability**
   - Complete audit trail (every event in queue)
   - Message replay possible for debugging
   - Compliance records automatically generated

7. **Future Evolution**
   - Easy transition to CQRS (separate read/write models)
   - Event Sourcing migration (store all events)
   - Microservices decomposition

### Negative consequences

1. **Eventual Consistency**
   - Appointment created in Producer
   - Notification sent asynchronously later
   - Brief period where systems out of sync
   - **Mitigation**: Acceptable for appointment system (notifications 1-2 seconds delay is fine)

2. **Complexity in Debugging**
   - Request flow no longer linear
   - Need to trace events across services
   - Requires correlation IDs in logs
   - **Mitigation**: Structured logging, distributed tracing tools (Jaeger)

3. **Message Ordering**
   - Multiple consumers might process events out-of-order
   - If Consumer-1 processes before Consumer-2 due to timing
   - **Mitigation**: Design handlers to be idempotent (ADR-002)

4. **Infrastructure Dependency**
   - RabbitMQ must be running (in docker-compose)
   - If RabbitMQ down, no events processed
   - **Mitigation**: RabbitMQ cluster for HA, health checks

5. **Learning Curve**
   - Team must understand async messaging
   - AMQP protocol knowledge helpful
   - Different mental model than REST

## Implementation Status

### Completed

- [x] RabbitMQ in docker-compose.yml
- [x] Producer publishes AppointmentCreatedEvent
- [x] Consumer subscribes to @MessagePattern
- [x] Queue configuration with DLQ
- [x] Error handling and retries
- [x] Integration tests validating message flow

### In progress

- [ ] Monitoring/metrics for queue depth
- [ ] Dead-Letter Queue consumer (process failed messages)

### Future enhancements

- [ ] Message encryption (sensitive data protection)
- [ ] Distributed tracing (correlation IDs across services)
- [ ] RabbitMQ cluster (HA setup)
- [ ] Message versioning (schema evolution)

## Related Decisions

- **[ADR-005](./ADR-005.md)**: Domain Events implement the actual messages published
- **[ADR-001](./ADR-001.md)**: Hexagonal Architecture provides decoupling points
- **[DEBT_REPORT.md](../DEBT_REPORT.md)**: §5 (A-05: Event-Driven architecture)

## References

### RabbitMQ Documentation

- [AMQP Protocol](https://www.rabbitmq.com/tutorials/amqp-concepts.html)
- [RabbitMQ Exchange Types](https://www.rabbitmq.com/tutorials/tutorial-three-javascript.html)
- [Dead-Letter Queues](https://www.rabbitmq.com/dlx.html)

### Event-Driven Architecture Books

- **Newman, S.** (2015). _Building Microservices: Designing Fine-Grained Systems_. O'Reilly.
  - Chapter 5: Splitting the Monolith (messaging patterns)

- **Richardson, C.** (2018). _Microservices Patterns: With examples in Java_. Manning.
  - Pattern: Event sourcing
  - Pattern: Saga (distributed transactions)

### Code References

- **docker-compose.yml**: RabbitMQ configuration
- **src/infrastructure/event-publisher/**: EventPublisher implementation
- **src/events/**: Domain event definitions
- **backend/consumer/src/notifications/**: Consumer handlers

### Metrics

- Publishing latency: <10ms
- Message delivery guarantee: At-least-once (configurable)
- Max queue depth: 10,000 messages (configurable)

## Approval and Evolution

| Version | Date       | Status      | Notes                        |
| ------- | ---------- | ----------- | ---------------------------- |
| 1.0     | 2026-02-20 | ACCEPTED    | Initial MVP implementation   |
| TBD     | TBD        | ENHANCEMENT | Add monitoring/observability |

---

**Document Version**: 1.0  
**Last Updated**: 2026-02-20  
**Next Review**: 2026-05-20 (Post-MVP)
